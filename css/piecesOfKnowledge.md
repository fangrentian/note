# 标准文档流

* 宏观角度: 可以理解为,页面的解析顺序,从上到下,从左到右;
* 微观角度:
  * 空白折叠现象,如图片之间会有一点间隙;
  * 高矮不齐的时候,底边对齐;
  * 自动换行,一行写不满,换行写;
  
# 块级元素和行内元素

* 块级元素: 自身的特性不能与其他元素并列,可接受快读和高度;不设置宽度的话,那么宽度变为父级元素的100%宽度;

* 行内元素:自身特性不能设置宽度和高度,默认的宽度和高度就是文本的高度和宽度;可以与其它行内元素并排显示;

块级元素和行内元素的自身特性可以通过display修改,块级元素和行内元素可以相互转换,比如在标准文档流中 **display:inline** 把块级元素变为行内元素**display:block** 把行内元素变为块级元素;

## 实现并排显示块级元素的方法

1. css中脱离标准文档流的方法
   * 浮动  
   * 绝对定位   
   * 固定定位

2. 不脱离标准文档流
   * display:inline-block
   * flex:弹性布局

# 浮动元素
浮动的四个性质(脱标 贴靠 字围 收缩)
* 浮动的元素脱离标准文档流;
* 一个元素浮动后,就可以并排显示,且可以设置宽高,不管该元素是块级元素还是行内元素,不需要display来转换块级和行内;如果有足够的空间,浮动的元素依次相互贴靠,如果没有足够的空间,则后面的元素依次逐级找空隙向前面的元素贴靠;
* 浮动元素以后,文字不会到浮动元素的下面去,而是会围绕浮动的元素分布;文字的效果和div的效果不一样;
* 如果浮动的元素没有设置width,那么该元素将自动收缩为文字的宽度(很像行内元素);

## 浮动的清除

1. 给浮动元素的父元素添加高度属性(就是浮动的元素在哪个元素里浮动就给哪个元素设置高度),来清除浮动对其它元素的影响.但是我们不推荐使用,因为不设置高度,构架页面更加灵活,高度可以根据内容自己调整.

2. 通过clear:both来清除浮动,但是会使margin值(有些元素自带margin值)失效,所以该方法不推荐使用;

3. 隔墙法
   * 外墙法
   在两个浮动元素之间插入一个空元素`<div></div>`,设置clear:both;
   * 内墙法
   当父元素依靠子元素撑起高度或者两个元素之间需要一个高度的时候,一旦子元素浮动而父元素没有设置高度,父元素的高度就会变为0,这时可用内墙法;
   在浮动元素内增加一个空元素`<div></div>`,设置clear:both,可以给这个空元素设置一个高度,来设置上下两元素之间的距离(因为一般我们会在页面中先设置margin=0和padding=0,这样上下元素就没有距离了).

4.overflow:hidden

子元素浮动后,父元素如果么有设置高度,则父元素会变成一个没有高度的盒子,这时给浮动元素的父元素设置overflow:hidden,就可以把父元素撑起来一个高度,这个高度就比较智能,永远会包住子元素中最高的那个元素.

overflow:hidden最初的用处是隐藏溢出的文本.

# 浏览器兼容问题

* 在IE6中不支持小于12px的盒子,任何小于12px的盒子,在IE6中看起来都会变大,解决办法: 设置height:4px;_font-size=0;
* IE6里不支持使用overflow:hidden来清除浮动,解决办法,overflow:hidden;_zoom:1;
实际上_zoom:1能够触发浏览器haslayout(IE浏览器渲染引擎的内部组成部分,是渲染引擎的一个属性)机制.

# 在HTML中三种使用css的方法

1. html中的link标签引入外部css文件；
2. html中使用style标签中写入css代码；
3. html中通过style属性把css代码写在标签里面（不推荐使用，因为新的理念为结构,样式,行为分离，HTML负责结构，css负责样式，js负责行为,不提倡混合输入的写法）；

三种方式生效的优先级别为3>2>1，即同一元素有不同的样式时，方式3的样式起作用；

# css的继承性,层叠性及权重

* 继承性: 有一些属性，当给自己设置属性的时候，自己的后代都会无条件的继承，这就是继承性；
可以继承的属性：color、text—开头的、font—开头的，这些关于文字样式的，都能继承，所有关于盒子位置、浮动、定位等布局相关的属性都不能继承；

* 层叠性：css中设置有冲突的解决方案，通过比较权重来解决冲突问题，而且没有兼容性的问题；

* 比较权重：ID的数量、类的数量、标签的数量，而且顺序不能乱，即先比较ID的数量，再比较类的数量、最后比较标签的数量，ID数量大的权重大，ID数量一样的，比较类的数量，类的数量大的权重大，类的数量一样的，比较标签选择器，标签选择器数量大的权重大。

题外：255个标签的权重约等于一个class的权重。

如果权重一样，且全部都选择到了标签，那么谁后出现就以谁为准（即后定义的属性为准）；

如果不能直接选中某个标签，则是通过继承性影响的（选择的是父级元素），权重为0，如果大家都为0（都没选择到目标标签，而是选择到了父级元素），那么遵循一个原则：就近原则，那个定义离目标标签近的，就以谁为准。

## css权重比较

1. 先看是否选择到了目标元素，如果选中了，就比较权重（ID、class、标签），如果权重一样，谁后设置，就以谁为准；

2. 如果都没有选中目标标签，那么权重都为0，如果大家的权重都为0，那么以就近原则确定实际显示的样式；

3. 比较权重的时候，如果遇到并集选择器，那么并集的各个部分应分开比较；

4. 设置样式的时候，与标签中class名的顺序没有关系（有多个class名的时候），如果都选到了目标标签，谁后设置就以谁为准；

5. !important
   * !important用来提高css样式中某个属性权重到无穷大，格式（p{属性：属性值 !important；}）；
   * 只能够提高一个属性的权重，而不是一个标签的权重；
   * 而且!important不能提高继承的属性的权重，该0还是0；
   * !important不影响就近原则（都没选中目标标签的时候）；
   * !important只有在都选中目标标签的时候，才能起作用；

# css基本选择器

1. id：选择标签最为准确，格式#id名,区分大小写，同一页面内id名不能重复；
2. class：选择标签的时候会选择class名字相同的标签，格式为.class名；
3. HTML标签选择器：用标签名当做选择器,所有的标签都能够当做选择器（doctype不是选择器，是声明），不管这个标签藏得有多深，都能够被选择到，选择的是当前页面的所有被选择器选择到的标签，而不是某一个。所以通过标签选择器设置的都是共性特征，而不是某一个标签的特征。
4. 通配符*选择器：选择HTML里的所有标签；

以上选择器选择的准确度顺序：1>2>3>4；

一个标签可以同时被多个选择器选择，但是最终显示的样式是优先级（权重）最高的，会把优先级低的选择器设置的样式给覆盖掉（多个选择器设置的样式有冲突的时候），而不是给取消掉了，所以css叫做层叠样式表；

# css3中使用的几个选择器

* 后代选择器，子元素选择器，相邻兄弟选择器，普通兄弟选择器，有兼容性问题（大部分兼容性出现在IE6、7）;
* 子选择器：用>表示，如div>p，表示div标签的下级标签p，子选择器只能选择直系子元素；ie7开始兼容，IE6不兼容;
* 序选择器: IE8开始兼容，IE6、7不兼容;

1. 交集选择器：标签名.类名（标签名#ID名），表示某标签下某个类名的标签，如h2.test。能让选择器找的更精确，提高了选择器的权重；
2. 并集选择器：标签选择器之间用逗号隔开，如h2,p,a{}；
3. 子元素选择器：选择的是标签的直接后代，如div>span{}；
4. 后代选择器：选择标签下的某一类标签，如div span{}；
5. 相邻兄弟选择器：选择的是与某标签相邻的某标签，如，span+h3{}，表示选择的是所有与span标签相邻的h3标签；
6. 普通兄弟选择器：选择的是兄弟元素，不管是否相邻，如，span~h3{}，表示span的兄弟元素（同级）h3，不管h3是否和span相邻；

# 盒模型

## 盒子中的区域

一个盒子中主要包含五个元素（属性：width、height、padding、border、margin）

* width：盒子的宽度，严谨的说，css中盒子的width指的是盒子内容的宽度；
* height：盒子的高度，也指的是内容的高度；
* padding：内边距，内容到border内侧的距离；
* border：边框宽度；
* margin：border外侧到另一个盒子border外侧的距离；

## 认识width和height

一个盒子在页面中实际所占空间为：width+height+padding+border

## padding

内边距，当设置背景颜色的时候，padding的区域也是有背景颜色的，设置padding的时候会加大盒子所占空间，如果同时不想盒子所占空间加大，可以将盒子width和height减小2倍的padding值；

## 设置不同方向的padding值

### 方法1：
* padding-top
* padding-botton
* padding-left
* padding-right

### 方法2:设置简写值

padding：值（1~4个值）；设置的值顺序是上右下左

当设置padding值得时候可以写做`{padding:400px；padding-left：30px；}`但是不要写成`padding-left：30px；padding:400px；`，即顺序不要颠倒；

一些元素默认带有padding和margin，比如ul标签，我们在建立网页的时候，为了便于控制，通常总是清除掉这个默认的padding和margin，可以用通配符选择器来清除；但是效率不高，可以采用并集选择器，罗列所有要清除padding和margin的标签；

## margin的一些特性

使用margin来居中达到居中显示元素时, 元素是在其父容器中居中;

设置子嵌套元素的margin值有时候父元素会相对更外层的元素同时移动相同的距离,要消除这样的情况,在父元素中设置border就可以,但是border在各浏览器中显示效果有细微的差别,所以设置嵌套元素间距时尽量使用父元素的padding属性,少用子元素的margin属性;

### margin在ie6中的兼容问题

1. 有双倍margin值的bug: 当出现连续浮动的元素,携带和浮动方向相同的margin时,队首的元素会有双倍margin值; 解决该bug的方案:
   * 使浮动的方向和margin的方向相反;
   * 使用hack(不推荐使用),单独给队首元素设置一个一半的margin(_margin-left:20px只有ie6能识别);

2. ie6的3px的bug: 当左边的DIV浮动**float:left**起来后，右边的DIV就可以接着排过去, 这时在ie6下,两个元素之间会有3px的间距,
解决办法是给左边浮动的元素添加 **_margin-left:-3px** 属性(ie6 hack写法).

# 行高和字体

css中所有行都有高度,主要指文本.盒模型中padding可以调整文字的位置,但是padding不是直接作用在文字上的,而是作用在文本的"行"上.行高可用用百分比来表示,表示字号的百分比,通常来说都是大于100%.

* 单行文字在父元素中垂直居中: 把行高设置为父元素的高度就可以.
* 多行文本在父元素中居中: 设置padding调整文本到中心位置.

## 字体

* font:为缩写格式
* font:字号/行高 字体族科
* font-family:字体

网页中不是所有字体都能用,因为要看用户的电脑里有没有安装你设置的字体;

实际开发中为了防止用户电脑里没有安装我们页面里用的字体,我们采用一些备用字体,用逗号分开,如font-family:"宋体","微软雅黑"

页面中,中文网站常用:微软雅黑,宋体.黑体,楷体, 英文网站常用:Arial,times new roman 中英文网站:通常把英文字体写在前面, 如font-family:"times new Roman","微软雅黑","宋体"

# 超链接的美化

`<a>`标签在使用的时候,需要注意的事项非常多, 不仅要控制a标签的链接,还要控制a标签的转换,还要操控它的伪类.

## `<a>`标签的伪类
1. :link
2. :visited
3. :hover
4. :active

`<a>`标签中,描述的是盒子.伪类描述的是文字的样式和背景;

* :link.给没被访问过的链接设置样式
* :visited.给访问过的链接设置样式
* :hover.鼠标悬浮在链接上时的样式
* :active.链接被点击单没有松开的时候的样式

a标签中使用伪类的时候要遵循固定的顺序,否则不生效.

# 背景颜色

* background:颜色 图像 平铺 位置  固定;(缩写形式)
* background-color:背景颜色
* background-image:背景图片
* background-repeat:背景图片重复方式
* background-position 背景定位
* background-position:x y(可以使用方向单词来定义位置);
* background-attachment设置背景是否固定,设置为fixed时背景不会随滚动条而移动.

实用情况,大背景图居中和通栏banner居中packgroung-position:center top;,防止背景图片过大,页面不能完整显示或者出现滚动条.

# css cprite

css雪碧图,css精灵, 采用雪碧图是因为能够减少http请求, 加载一张图片就会向服务器请求一次,用的图片越多,向服务器请求的次数越多,服务器响应时间就越长.

加载一张雪碧图,采用background-position来定位要显示的内容.


# 定位

## 相对定位: 
**position:relative**,用来微调元素的位置.

* 相对定位的移动参考是自己,相对自己原来的位置;
* 相对定位的元素不脱离标准文档流,移动前所在位置空间还在,其它元素不会像浮动那样自动移动到相对定位元素原来的位置.
* 相对定位可以做绝对定位的参考,子元素是绝对定位,父元素是相对定位.
* 在相对定位中,可以使用left right来表示盒子左右的移动,用top和bottom来表示盒子上下的移动.

## 绝对定位

* 绝对定位比相对定位更加灵活;
* 绝对定位的盒子会脱离标准文档流,所以在绝对定位中,不区分块级元素和行内元素.
* 绝对定位的父元素,最好使用相对定位. 父元素如果是绝对定位或者固定定位,那么父元素和子元素都脱离了标准文档流,导致页面布局不稳定.
* 绝对定位的元素,会忽略父元素的padding值
* 设置绝对定位的元素会使其设置的margin失效,比如会使margin:0 auto;失效,如果还要居中效果,则设置绝对定位position:absolute;left:50%;margin:-width/2;则恢复居中效果.

## 固定定位

固定定位,就是相对于浏览器窗口定位,页面如果滚动,固定定位的元素不会改变,固定定位的元素会脱离标准文档流.

## 定位参考
一个盒子设置了绝对定位,并不是相对于自己原来的位置进行移动的,而是相对于具有定位属性的父级元素进行的一个移动.如果父元素没有定位属性,那么久继续找更上一层的父级元素,直到找到具有定位属性的父级元素,如果父级元素们始终没有定位属性,那么就以body为参考.

# z-index

显示层级

* 只要定位的属性都存在z-index值,默认值是0,如果没有进行设置,两个盒子重叠的时候,那么后面的盒子会覆盖掉前面的盒子.
* z-index没有单位,就是一个正整数.如果大家都没有z-index值或z-index值一个,那么后面写的元素会覆盖前面写的元素.
* 从父现象:父元素z-index值低的元素设置再高的z-index值,其显示样式也不能置于父元素z-index值高的元素之上.
* IE6不支持固定定位.在ie6里面要把导航条固定在窗口顶部,应额外设置_padding-top=0px;(导航条设置固定定位后会脱离标准文档流,后面的元素会跑到导航条下面去,为了避免这种情况,我们会给body设置一个宽于导航条的padding值,但是在ie6中不支持固定定位,所以导航条也会跟着下移一个padding值,为解决这个问题,应针对IE6额外设置_padding=0px)